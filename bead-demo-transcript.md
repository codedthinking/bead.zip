# Bead CLI Demo Transcript

## Introduction

This transcript captures a comprehensive demonstration of Bead, a command-line tool for reproducible computational research. Bead addresses the daily challenges researchers face in tracking data versions, reproducing results, and maintaining computational workflows. The tool was developed to solve the problem of tacit knowledge about data being destroyed when team members leave, leading to duplication of effort and inability to reproduce research results.

Miklós: I'm just going to use the audio for this. And I've already started it with an ESC keyname. The shell, just a moment.

Krisztián: Sorry, is the recording public or not?
Miklós: No, no, I just want to use it for I'm going to download the audio. I'm also going to do something with the zoom, which is good enough. I'm going to download the transcript. It's going to be a text file. And then with the code and the screen, we're in the screen capture. I'm going to type in to Claude, that's it. This is a user-facing documentation. So, let's switch to English. This is the beginning of this beautiful recording. Please, we are in awe of our AI overlords. Please, please. We are very friendly. Come bearing gifts. So this is a demo of `bead`. And I need my list of things to cover. And so here I have an empty folder that I just created. There's nothing here except for the screen recording that is happening as we speak. And so let me first illustrate single-bead workflows. I think that was the idea. What can we do with a `bead` before even linking them together with multiple other `beads`? When we're not thinking about dependency management, basically just versioning.

## Single-Bead Workflows

In order to create a new `bead`, I need to use the `bead new` command. And I think I'm going to create a new `bead` of German cities because that's going to be relevant for some projects. I'm going to call it German cities. It created this folder. I go in. Let's see what's inside the folder.

```bash
# Creating a new bead workspace
$ bead new german-cities
Created "german-cities"

$ cd german-cities

# View the directory structure
$ tree -hal
.
├── [  96]  .bead-meta
│   └── [ 105]  bead
├── [  64]  input
├── [  64]  output
└── [  64]  temp

5 directories, 1 file
```

There's a bead metadata, which at some point we can look into in the more advanced topic, there's an `input/` folder, an `output/` folder, and the `temp/` folder. And we understand the logic, but let me say this because maybe our AI overlords not yet understand that the input data, which we don't yet have, are going to live in the `input/` folder. Everything we want to save for the future and we want to pass on to downstream beads are going to live in the `output/` folder. and everything that's in the `temp/` folder is going to get deleted. So what happens to files that are not in any of these folders? They are going to get saved as code. So typically where we would put code, but we can create other folders as well if we like, and that's going to be treated as code by `bead`. Feel free to interrupt me or correct if I'm saying anything stupid or ask questions. So, [593]

```bash
# Creating the cities data file
$ nano output/cities.txt
# (Editor opens with German cities data from Wikipedia)
```

Let me pull, I'm just gonna random Wikipedia. Actually, how am I doing with my work? List of cities and towns in Germany from Wikipedia.

Andris: Is there a way to... I'm just going to copy paste from there.

Miklós: Not a very sophisticated method now, but... Oh, and it actually has the state, which is great because that's what we actually need in the research. And because that's going to be the data file that I want to save, I'm going to directly put it in the `output/` folder. I just copied this over from Wikipedia. We would need to check the formatting and everything, but now I don't care. So now we have cities in the `output/` folder, so that's our data file. It's actually good practice to add the README as well. I would add it to the `output/` folder so that whenever somebody uses this `bead`, they will see what's inside the `output/` folder. And any data documentation should live in the `output/` folder as well. This was the link. And of course, there's Andris and, well, it was the editor, but that's okay. That's not a proper readme yet, but again, good enough for now.

## Bead Boxes and Saving

So this is what we have in our folder. So now that we have this `bead`, I call this an open `bead`. The official name is a workspace, I believe, Krisztián. Maybe this is something to discuss tomorrow, the naming. But this is one example where we have an open `bead` and I want to save it so that I can share it with someone else. Maybe Andris is interested in German cities because he wants to allocate the firm data that we got from Paltorai to East Germany and West Germany. When I will save the `bead`, it creates a zip file and put it into a special folder, and that special folder is called a `bead box`. And in order to check which `bead boxes` I have defined, I can use the command `bead box list`. I already have a bunch of `bead boxes`, but I'm going to create a new one for the sake of this demo.

```bash
# Getting help for bead box commands
$ bead box --help
usage: bead box [-h] {add,list,forget,rewire} ...

positional arguments:
  {add,list,forget,rewire}
    add                 Define a box.
    list                Show known boxes.
    forget              Forget a known box.
    rewire              Remap inputs.

optional arguments:
  -h, --help            show this help message and exit

# Listing existing bead boxes  
$ bead box list
Boxes:
-------------
cat3: /Volumes/Data3/beadbox
cat2: /Users/koren/Downloads/beadbox
private: /Volumes/Data3/cat3-bead-box
```

And I forgot how to do that, so I'm going to ask for help because this is a proper command line tool. There is a help for every subcommand. `bead box add`. Put it in the downloads folder. `bead box`. Okay, am I doing this right? Maybe I need to add a name. I need a name. Positional arguments. Okay, the help does not say that I need a name. Like this. Let's see if it works. I need to create the directory first.

Andris: Okay.
Miklós: And now I'm gonna, again, `bead box demo`. So let's see what happened. Sorry, go ahead.

Krisztián: There is also a help for the add command, so `bead box add`.

Miklós: Okay, and then `bead box add`, and then I check the help. Oh, okay, okay. And then there's an environment, which I don't know what it is, I have to admit. So I will not touch it now, but maybe tomorrow we can discuss. So now my `bead boxes` include a demo.

So what I want to do with my open `bead` or my workspace, I want to save it into this demo `bead box`. The command for this is `bead save`. I suppose that I have to give the box. Let's see. Yes, box parameter is not optional. We can check how this works. `bead save`. Again, I say which workspace and something about the environment, which I still don't know, and where. And the where is going to be the demo. So I don't have to say the fully qualified path, I just need to use the short name of the box.

```bash
# Saving the bead to the demo box
$ bead save demo
Successfully stored bead at /Users/koren/Downloads/workspace/demo-bead-box/german-cities_20250730T153158789876+0200.zip.
```

Super convenient. `bead save demo`. We already got some nice feedback that there's a zip. I'm actually going to list the content of that. Can I list the content of a `bead box`? Is there a command for that? Let's check. It's just a directory. So I know just `ls`. Okay. So I'm going to then list. This is where the demo `bead box` was when I want to show a bit of details. So now we can see that what we created is a zip file. It's called German cities. It begins with German cities. It's rather small, partly because my data is small and partly because it's compressed. And then there's a timestamp when it was saved. So that's how I save a `bead`. So this is what I would refer to as a closed `bead`. And when I work on it in a folder, I call it an open `bead`. But I think, again, the proper word is workspace for that. So suppose I go up one level. And so I have here my German cities folder. And I went for coffee, had lunch, everything. Actually, maybe it's two weeks later. I don't even remember what's inside this folder. Now that I saved the `bead box`, I don't need this folder anymore. Saving the `bead box` is like a `git commit`. Everything I wanted to, and it's actually `git commit` and `git push` because I also pushed it into the `bead box`. Everything I want to keep from the folder is now inside the zip. What's not inside the zip is the `temp/`. We will check that in a second. I was tempted to delete that folder because I don't need it anymore.

But let me show you something why it's not going to be an easy task. Check the permission flags here. The `input/` folder is read. I'm sorry, write protected, so it's read only. There's a very good reason for that. We are not letting you touch the input data. You can only mount the input data or add input data via `bead`, and you're not supposed to modify the input data because it's an ultimate sin of data analysis. But because it's read-only, it's very hard to start deleting stuff. So we need a special command for deleting an open `bead` once we're done, and it's called `bead zap`, I believe, but let's check. So this is actually typically how I use `bead`. I never say which directory, so I'm working inside the `bead`. This is something to think about if anybody uses it in a different way. I guess it's still useful to have that option, to have the workspace directory option, but Andris Bálint, have you ever used the directory option when you're working with `bead`?

Bálint: Yes, sometimes when you are outside the `bead`. So now you are in a folder that does not exist. So that may cause some confusion, but yes.

Miklós: Okay. So let me move right out. My shell did not complain.

Bálint: If you want to delete multiple `bead` workspaces, then it's very useful if you have the directory. So you don't have to go into.

Miklós: Okay, so like here I could be `beads`, I could be like multiple open `beads` or multiple workspaces and delete them with the `bead zap workspace1` and `workspace2`. So now we have deleted that. So there's nothing here except for the recording. You know, the zip is still there.

## Opening Beads and Sharing

So how do I get back the stuff from the zip? Let me, suppose I sent my file to Andris and Andris is not yet a `bead` user. So what Andris sees is the zip file. So Andris received a copy of the zip file. Important to note here that `bead` does not do anything about sharing the `beads`. So you have your own `bead boxes`. If you live in an environment where these folders are shared, like on a network drive or you're on a server, then of course others will see these zip files as well. But it's your responsibility to get the zip file to your co-author, collaborator, whoever you're sharing it with. So `bead` is about the frozen computation and the dependency and version management and not about the actual sharing.

So now we've happened to get a copy of the zip file. So let's see what's in there. I'm going to `unzip` it.

Andris: Oh.

Miklós: Okay, now I understand what happened, but not what I expected. Because, you know, when I double click on Mac, that's not what... Let me... because I want to put it in a separate folder. I'm going to remove these things here. Again, I got a copy of the zip file and I'm going to `unzip` it. How do I put it into a specific folder?

Andris: Dash D.

Miklós: That's what I will call the folder, not a very pretty name, but that's like the name of the zip file. Now I'm inside the unzipped. This is not how you open a `bead`. This is basically kind of an emergency measure to open a `bead`. If you don't have `bead` in your tool because you're at an airport, there's no internet, something, but everything you need from the `bead` is there. It's just we have not used the proper `bead` tools. So inside the `bead`, there's some metadata, which, you know, again, in advanced topics, we can look into and in the `data/` folder, we have what we put in the `output/` folder before. We can check that this is the README and this is the actual data of the different cities. So if you give the zip file to someone else who has no idea what `bead` is, they still get the data. Good. They would even get the code. They would probably not be able to run like this because things are not in the right place in terms of the folders. But they still have all the metadata. So they still have everything, they just don't... They cannot really use it as a `bead` command line tool. So now I go back, I'm going to remove this folder. There was nothing write protected here, and I'm going to remove the zip file as well. Remember, we have a copy in the `bead box`, so it's okay. So this was Andris because he didn't have `bead`. He is at the beach and he has no `bead` there. So he was looking into the zip file.

But Bálint has `bead`. So when I share this data with Bálint and he wants to continue working on the same data, he would open it in a different way. He would open it with `bead develop`. That's for help. And we can say, you know, what's the name of the `bead`? It's a `bead` ref. Archive file name or a `bead` name. So I guess we could give like the full archive file name. Krisztián, that means the full zip file.

Bálint: That without the timestamp. So. Before the underscore German cities.

Krisztián: But both will work, no? If you give the full name, I mean, it's a file path, it will work. If it's not, if you load it from a box, you either have to give the full path from the local directory to the box and its content, or just give German cities?

Miklós:

```bash
# Recreating workspace from saved bead
$ bead develop german-cities
Verifying archive /Users/koren/Downloads/workspace/demo-bead-box/german-cities_20250730T153158789876+0200.zip ... OK
Extracted source into /Users/koren/Downloads/workspace/demo-2025-07-30/german-cities
```

So the way I use it is typically with the short name, but let's, so let me show that. And there the `-x` option, extra output data. So that's actually interesting. So that the default here is false. I, whenever I develop, I always use it, but I think it might be different for Bálint, who is working with very large data sets. So whenever I open it, I always want to check what's in the `output/` folder. This is actually a good case, what we're looking at here.

Bálint: Correct. In our server, I always use with `bead develop -x`, but we started to work in the admin and cache a research room. And it's very good that, uh, if there is not, is there, there is a basic option is not to use `-x`. I guess, I guess it makes sense to, to, to make this a choice.

Miklós: Uh, the reason why it's important to use `-x` here. So, uh, let me go into German cities and, um, see what's inside. We're actually back to where we were a couple of minutes ago. We have the metadata and we have the output that we put there. So the reason why in this case it's very important because we don't have any code generating the output. This is what we have is a so-called... How do we call this? This is like a raw data `bead` or if you think So you will see in the second part of the demo that `beads` can be linked in directed acyclical graphs of how one `bead` is using the output of another. So it's a DAG. And so if you want to use the DAG terminology, then this `bead` is a source node. So there's no input coming in here. I just manually copied data from Wikipedia. I could have added some code to download the data from Wikipedia, then it would have been a proper `bead` because some code is creating the output. So then I'm going to make some changes. Before that, I'm going to illustrate `bead develop`. Opened it, deleted it, nothing happened. We developed German cities, but I didn't give the `-x` option. And then there's nothing in the `output/` folder. I still have the metadata, of course, but there's nothing in the `output/` folder. How do I load the output? Can I load the output or not anymore? No, it's gone. So then I `zap` this and I go back to my favorite way of open. Now I was in a non-existing directory, indeed. The error that Bálint pointed out.

Andris: And now it's working.

Miklós: By the way, the message we're getting here is that it's actually looking into the, actually what's happening, if I understand correctly, Krisztián, it's looking across all of the `bead boxes` and searching for a `bead` that matches this short name. And then verifying that this is what we need. There was some reference by some magical numbers, but I think nobody's using those. So I think we're only always referring by name. Kind of shortish names like this one. I could, I think in `bead develop -x`, I could also say which specific version. Hang on, we didn't do version yet because we're not there yet in the demo. So now I go into German cities. I do a bunch of these for the screen recording to see what's inside. And now let me actually edit a little bit the city list and say, oh, there's some formatting stuff that we don't need. Okay, I'm not going to do too much editing because this is about `bead`. So let's save the... Let's save the file. So now this `cities.txt` has a later timestamp. The timestamp is new. The timestamp is from the time of developing, I guess. So `bead` does not save the timestamp. That's a question. It probably does not.

Bálint: Maybe you can use the bead status now to show what. Oh, there's a command.

Miklós: So let's see what other comments there are. Actually, that's a good.

Bálint: It'd be Xmeta then.

Miklós: That's an export, that's an export stuff.

Bálint: No, what I wanted to- Okay, but you can check in the hidden bead meta directory.

Miklós: So you do have a freeze time. Freeze time. The freeze time is when it was saved, which was right a couple minutes ago. I haven't yet saved the time. This timestamp is when I opened the bead, not when it was saved. The reason I'm asking, and I think this will become a feature request, this is not for our current documentation. You might as well open a feature request on GitHub. or stuff like make timestamps are important. I don't know if zip can store timestamps or whether it cares or not. So maybe if it's a complicated request, then forget it. This is something that would be nice to have, but definitely not essential. In any case, back to the demo, we see that cities is now newly modified. So we have a new version of the bead. I'm going to reflect the new version of the README as well.

## Versioning and Checksums

Change log, we have... What is the... Remove down formatting lines. We are saving it. and now both files in the `output/` are new. There's no special comment for that, we just save it again and then it's gonna create any number of times we save it, it's gonna create a new version. `bead save`, I think we called our `bead box` demo. So you can check the timestamp here, that's now a different timestamp. Now we have two zip files in the `bead box`. German cities, but zip in between with different timestamps. Of course, every time you save a `bead box`, it's going to create a new, I'm sorry, every time you save a `bead`, it's going to create a new zip file. For large data, it can be quite a bit of overhead, but in our experience, Storage is typically not an issue. So it's better to have like multiple copies floating around than to lose a version. So every version is saved into a new zip file. Krisztián, I believe that there's no checksum checking or anything at this stage. So if I created or content checking, if I say `bead save demo`, it's going to create another one. with the same content in a different timestamp, right? Is there any checksum checking at the loading stage?

Krisztián: Yes, it is verified. So there is a manifest file in the leads. And for every file, there is a checksum of secure hash, content hash for the file. And when extracting it, it is checked.

Miklós: So then you can be certain that you're using the proper stuff and someone could have tampered with the zip or something. But it's not really a security feature because if someone wants to tamper, they will be able to. So it's just a nice, more like an error checking feature. Maybe here, one thing to illustrate is that I already saved a bunch of these, so I can zap this. I'm going to go back to my folder, the demo folder. Now I have three different versions of the German city. If I give it to Bálint and he starts working on it, he might want to work with a specific version.

How do I do that? And I `bead develop`. I guess I could give the specific file, right? I will try. `bead develop -x`?

Andris: What are the options? Day 51.

Miklós: Okay, so I gave a fully qualified file name and then it loaded that. We can check whether that's the proper file inside the `.bead-meta/`. We can check the freeze time. It is indeed 1551 as we asked for. So we are happy. Actually in this, and then of course check the... So where is the hash? Is it only for the inputs or?

Krisztián: No, it's not here. So, It's not in the bit file, but there is a meta data, but it's not here. It's only in the zip file.

Miklós: It's in the manifest in the zip file. Let's see if I can, this is now a bit advanced topic, but I think it's useful to know I'm learning More about this as well. I think I can look in here with less. No. I'm just going to look into the zip file.

Bálint: Maybe you can use unzip view option. So.

Miklós: On the dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, dash, This will have to be edited, which is, I guess, hard-coded into the tool. But in the new version, we will have to change this. For example, I don't think we have on.io. Now we have bzip, which is an even cooler name.

Krisztián: You can print the manifest with unzip minus P. It will print only that file to the standard. Minus what, sorry? Minus P. P? P for print.

Hmm.

Miklós: And so here, okay, so here you have, this was the bead meta, and this is the manifest. And here are the, okay, now I learned something, so here are the ashes. Super cool.

Krisztián: Yeah, it summed everything, so we got the- Yeah, I could have given the name, I guess.

Miklós: But German city is a bead, I guess, so I'm going to zap it. So now I think this concludes our singular bead. I think we covered everything. There's one or multiple of these beads that don't depend on one another. We're basically using here beads for version control. I mean, I haven't actually added code. Maybe I could have. Let's do that quickly. German cities. And so suppose instead of manually copying files over to my output folder, I use a curl. From Wikipedia, I'm just kind of, you know, simulating some curl command output.

Andris: I guess it's the other way around, but Wikipedia. So, and then I'm saving it.

Miklós:

So what I have is I have the download script inside. It's not in input, not in output, not in temp. Let me also put something in the temp folder. So now I have stuff in the output folder, stuff in the temp folder, and I have stuff outside these folders. I can create any number of folders that I like. So for example, I could create, I don't know, src, and I could move over my file to src.

Andris: Maybe a good question for the documentation, where is the best place to put your codes?

Miklós: Yes, actually what I wanted to say now, and I think it's really nice. B does not assume anything about what code you use, how you run it. It's not executing the computation, you have to do it yourself. Everything beyond this is basically a matter of how you agree with your colleagues. It's a matter of convention and not hard rules. We were thinking about creating some entry points, and maybe in future versions it's going to happen. Suppose there's something like a make file in the top folder, then that could be a good place to try to run. But for now, we're just relying on human judgment that when Bálint opens this bid or Andris opens this bid, they will see what Andris sees. But Bálint will see that SRC download SH and he will realize that, okay, there's a script, let me run this. I think it's good practice to to be a bit more structured, so you have some sort of common understanding of how you're running computation inside your beads. So the way I do it, for example, is that whenever I have a bead, I also have a makefile. So every single one of my beads that I created has a makefile. And then the makefile does all the computations that are necessary. And the makefile lives in my root. in the root of the folder, but then I actually don't like to, unless it's a very short bit and there's only one or maybe two scripts, I don't like to keep my scripts in the root folder because then they clutter everything. I usually put my scripts away in some other folder. but then you need to tell the user what to run and having a make file or a main script is helpful for that. But again, this is just a matter of taste and negotiation with your collaborators. It's not enforced by the, what this is doing is, so far we have seen opening and saving these beads, newer and newer versions. And we're gonna check the input. input mounting or input loading in just a second. So let me save this again, because there's one other thing I want to illustrate. So we have saved it into the demo bead box again. And we're going to, now that we've saved, I can delete. And we're going to view the zip file. like this. And so now you can see where it gets put. So if Andris gets this file on the beach, and he does not have access to bead, he would find the actual data in the data folder. Very good, because that's probably what he needs. On the beach, he would probably not be able to run the code anyway. They are put in a separate folder. They are in the code folder. So what's code? Everything is code that's not input. not temp and not output. So my makefile is code and my src slash download is code. But notice what is not here. It's the, unfortunately I think scrolling is, maybe scrolling is also recorded in a SKU name. We put in the temp a junk file dot dat and it's not there. It's not there. So whatever was in the temp got deleted, got totally ignored. So temp is like git ignore in a way. What you put in temp is gonna die as soon as you save and delete the bit. I'm looking at Krisztián to see if I made any big mistakes so far. No, no, it's okay. So I think we covered everything about single beads, even more than I initially thought, but that's great.

## Dependency Management

But of course, where the `bead` really shines is when we start managing dependencies.

## Best Practices and Advanced Use Cases

Andris: Good question from the databank users that they're using their workspaces, that they are creating a workspace inside a workspace and they are putting versions of tables, data tables that they want to keep and they will be creating some kind of like `output/` folder for the final version. Can it be good in `bead` or it's out of the `bead` idea?

Miklós: I don't get the question. So it's like different snapshots or?

Andris: It's a different, they want to keep details that create the, for example, details that creating the final version that will be in the `output/`. So they are creating some kind of like a workspace folder and a lot of data table are there. So can we create a folder for the data? Or we must have to use only the `temp/` `input/` and the `output/` folder? That's the easier question.

Miklós: I see, I see. That's a great question actually, because this is exactly kind of how you use it and what's the use case. Now we don't have a large data set, but the idea is that Temporary data should live in `temp/`. So it's like if you're a Stata user, I don't know how many of our `bead`, but certainly the databank people are. If you're a Stata user, it's like a temp file. So stuff that you're not saving for a long time because you're gonna delete very soon. And I actually, I love that feature of `bead`. I used to save all kinds of intermediate datasets. Now all this data set is needed for that. That data set is needed for the other data set. These are like intermediate steps in like a long process. And the script is creating the end file anyway. Then I just put all of these in `temp/`. And then as soon as I save, they get deleted and I couldn't care less. Now I understand that the databank people, they do care. So they want to keep these `.dta` files. which I suppose might be because maybe not everything is done by code or it takes very long to run. That could be another reason. I mean, if these are intermediate steps, I think ideally they would be separate `beads`. So then we could come back to this after you do a bit of dependency management with `bead`. that would be my recommended solution. Again, probably I would ask, why would you want to keep these intermediate data files? If you want to keep them because you just cannot reproduce them from script, then you need to save them into a `bead`. The `bead` is freezing what you did in the past and it gets Notice what I have not done with those zip files. I have not deleted those zip files. They are there. As long as I have storage, I'm going to have hundreds of these closed `beads` in my `bead box`. If I just care what this `.dta` file looked like in the past, put it in a `bead`, and you have access to it. If the issue is not so much, or maybe you are using a script, but it just takes a long time to run, then I suggest you use a `Makefile`. because then it only runs what you actually need to run and not every single step. But then you don't need to save the intermediate files for perpetuity because you can recreate everything. And if you're still working, you can still keep working because your intermediate files are reused if you have them in your open `temp/` folder. But if you still want to keep them and you don't want to use a `Makefile` and you don't want to put them in their own `bead`, you can put it in any folder that's not `input/`, not `temp/`, and not `output/`, and it's gonna live there forever. It's gonna save, it's gonna get saved. It's just increasing the size of your `bead`. So one way we can... I think let's get back to this in the dependency part, because these are like undeclared dependencies in a way. It could be that sometimes we have stuff that, yeah, it's not a `bead`. We could put in a `bead`, but it would be really painful for some reason, but we still need the data. I'm going to show you a case for that. Another thing that's related to data bank and actually data security, `bead box list`. I think it's good practice. Again, it's not something that's enforced by `bead`, but I think it's something you can agree with your colleagues, is to have different `bead boxes` depending on the level of data protection, for example. because `bead` does not do any of this. It's a zip file. If someone has access to that folder and they can read the zip file and open it, they can read what's inside. If you want to do any data protection measure, you would have to take care of this at the folder level. For example, in this case, what I'm showing here is we have different data protection levels, category one, two, three, and category three data should always live in encrypted folders. And so my cat three `bead box` is encrypted and actually my private `bead box` is also encrypted. And so when I wanna, and I'm working with private data, I would be, well, I would be saving into a different `bead box`. But again, that's on you. But at least `bead` is flexible enough to give you that option. You can use multiple boxes. Another reason to use multiple boxes, if you're sharing with colleagues, you might have one in your Dropbox folder, you might have one on your computational server. I typically have more than one `bead box`.

## Input Dependencies

So suppose that we want to create some, yeah, let's create some dependencies. So for this we need at least two `beads` so that they can depend on one another. So I'm going to create a new `bead`, `bead new`. And let's say these are gonna be the German state. Of course, these are super mini `beads` in practice. such small datasets might be, and especially if they are so closely related, they might be lumped together. In German states, I'm going to, again, copy stuff from Wikipedia. Let's get a list of German states. Let's flag and everything, like what is going on here? Not that we care, but... Okay, at some point we're gonna get better demo data. So now we have `states.txt` and `README` in our `output/` folder. Now we already know how to save it. So we saved it. I'm going to `zap` it, go one level up. Let's see what's inside the `bead box`. Now there's a bunch of German cities, different timestamps and German states. So actually my point of the German cities was that I wanted to decide whether a city is in East Germany or West Germany. So I could open my German cities `bead` again. And then, in this other data, I already know which state belongs to East Germany and which belongs to West Germany. So I want to reference that data, and I want to load it as an input data here.

```bash
# Adding bead input dependencies
$ bead input add german-states
Verifying archive /Users/koren/Downloads/workspace/demo-bead-box/german-states_20250730T162550983335+0200.zip ... OK
Loading new data to german-states ... Done

# Viewing directory structure after adding inputs
$ tree -hal
[ 192]  .
├── [ 128]  .bead-meta
│   ├── [ 798]  bead
│   └── [  76]  input.map
├── [ 128]  input
│   ├── [ 128]  german-states
│   │   ├── [ 244]  README.md
│   │   └── [ 76K]  states.txt
│   └── [  96]  private-data
│       └── [   0]  filtered_data.dta
├── [  64]  output
└── [  64]  temp
```

And there is a set of subcommands for that, starting with `bead input`. I can declare an input dependency here. I can load the data. Loading is like mounting if you're in the Unix world. Yeah, it's big, unfortunately. But for the demo, we will use the proper data. For the screen casting, I don't wanna use any outside tool, not even a text editor. So I can declare the dependency by saying `bead input add`. German, well, actually, let's get the help first. `bead input add`. There's a bunch of optional options, but at least I have to give the input name, which is how I'm going to view it. And then I can refer to another `bead`. By far the most frequent case, which means I only ever use this version and maybe only Bálint used any other way, but we can ask.

```bash
# Example of incorrect command attempt
$ bead input private-data
usage: bead input [-h] {add,delete,map,update,load,unload} ...
bead input: error: argument {add,delete,map,update,load,unload}: invalid choice: 'private-data' (choose from 'add', 'delete', 'map', 'update', 'load', 'unload')

# Corrected command
$ bead input add private-data
Verifying archive /Users/koren/Downloads/workspace/demo-bead-box/private-data_20250730T165906219137+0200.zip ... OK
Loading new data to private-data ... Done
```

I would use bead input add, German states, then what it actually does is, and Krisztián, correct me if I'm wrong, but it goes looking around in the mounted bead boxes, so the bead boxes that I declared as such, these folders, looks around and there's something that looks like a bead called German states. It's found one, this zip file. It's verified that it matches my, later I think it will have more to verify, now it's just kind of the short name. And then it copies it over, it unzips the content, checks the checksum, I believe, and copies over the output of that, of that, of that bead. to the input of this bead. So here in the input folder, you see German states, and there we have the states.txt. But you could have all kinds of other, like you could ask for a specific timestamp of the input. You could rename the input so you could have a bead name, a bead reference, and you may want to call it something else in your own workflow. These are all options.

Andris: I don't think I ever used these options, but they're useful to have.

Miklós: So if we look into, I'm going to nano win today. So notice that what used to be output slash states dot txt is now input slash German states So this is the name of the input that we loaded, which happens to be the same as the name of the bead. That's a good, simple practice. And all the files that were in the output folder have been copied over here. Again, if these are large files, it does not really spare your storage because it creates a copy. But in practical terms, storage is very cheap, so it's not an issue. And this is the reason why we want to keep the README in the output folder, because if someone loads your bead into their own as an input, then they're not going to see the code, they're not going to see anything else from your bead, only the output folder. So if I were to actually let me check the README, If I say, what is in this B? Oh, German states that were copied from Wikipedia. Very good. That's what I'm looking for. I'm going to illustrate that. I want to delete this state.txt and it's right protected. it would ask me to, whether I really want to do that. And no, I did not want to do that. And so then I can add some logic in my code. a filter East. I'm just gonna add logic for filtering states by East Germany. So now I have my download and now I have my filter. And so actually, let me go back. So in my filter, I would refer to this input folder. Input, what was it called? German states, states.txt. And Gary, you are right. It would be much nicer to use some actual data. We're gonna practice with that as well at some point. So what this means is that, and this is actually an important point that we should be emphasizing in the user-facing documentations, because I think it's not obvious for analysts, it might be obvious for software developers, is that don't use absolute path. Everything here lives inside your folder. If you want to load data, first of all, do it with Bid, don't do it directly. This is related to András' question, which we'll get back to. And if you have loaded it with B, it's going to live inside your folder in the input subfolder, so you can access it like this with a relative path. You don't need to use absolute path. And of course, absolute paths are not the same on different computers, so you will get in trouble. And also, this is a way to enforce that you're not Again, this is not enforced by BID. We're just kindly asking you to do this, that you're not loading data from elsewhere or you're not, because we want to ensure the reproducibility of your research results. So this way we can know that this was the input data that you used. And so then the filtering and so after some data manipulation, the output would be probably updated. I'm going to update the readme in the output folder for now. filtered by East German states. So now I have a new version of the bid.

Andris: So it's ready to be saved into my demo.

Miklós: I'm not going to, I'm gonna leave this open. I'm not going to reset it yet because I will come back in just a second. So it's still there, but I do want to look into what's inside that bead.

Andris: I believe.

Miklós: And so, actually the list of files is the same. And we still print, there's nothing large in it, right? No, so we can still print. So what did change though, is where we changed the readme, by East German states. And also in the bead meta, the inputs are listed. the name of the input but also this long hash that we looked at before and the time it was frozen. This we can actually check in our workspace as well. So this beadMeta lives under the .beadMeta folder. to remain hidden. You're not to touch this. This is machine readable and machine written. I sometimes find it useful to look into this to see where things are and what's happening, but this is really kind of advanced debugging. But what we see here, which I think is useful to understand the working of BEER is that all the inputs are listed. There's only one set of inputs, German states, with their respective metadata. So now I'm back in my workspace. And for some, maybe I run out of space on my laptop. I need to remove the input data, be it input unload, German states. So it got deleted from the input folder. If I say build input unload, it unloads everything. All the inputs I have, I could have multiple inputs, of course. Of course, if I now back to my proper computer or purchase some more storage or delete some files, and I have space to load it, what is it called, German state, right? I can say build input load German states. And so what happened here in the background is that, sorry, I'm going to go back here. So now we unloaded the dataset, so it's not in the input folder, the input folder is empty. But it's still mentioned in the metadata file. So bead knows that I need this data, it knows the exact timestamp and the exact content hash that I need. So when I say bead input load German states, it checks whether it's the exact timestamp and the exact content hash that I need.

Andris: Is that correct, Krisztián?

Miklós: Yes. Some of the things were just kind of conventions, but these are some hard hard constraints, which I think is important. So, bead puts hard constraints on you on things that really do matter for reproducibility. So, for example, do you have the right version of the data? It's super important for reproducibility. Before we had beads, Those of you who were around, remember that this question of what version of the data did we use? How do we reproduce this? Which code did we run? What happened? Like every day we ask this question at least three, four or five times every single day. So it's very important to make sure that you have the exact same version of the data that you need. So that's what be the input load is doing for you. So I guess what bead input add is doing is declaring a data dependency and then loading it. bead input load is just making sure that your already declared dependency is now available for you in the input folder here.

I'm going to still keep this open in this workspace and go back one level. And I'm going to go back to my keep working on my states. I'm still not happy. Some, some of the data cleaning I haven't done yet. So bead develop -x, German States. So now I have two folders, German cities, German States. These are open workspaces. I can now edit my data. There's a lot of formatting here, which I don't like. Actually, I think this is all. That's the first data point, for example. Anyway, I made some changes. And because I made some changes, well, good practice to edit the readme as well. Remove some formatting. And then I'm ready to save. Now, I have two versions of German states. Actually, the newer version is a little bit smaller because I deleted some external junk. Now, let me go back to my German cities build. It's a workspace, sorry. Can I now load the German cities? German sorry state. And it's already loaded. Okay, so actually not only unload but load I can use without the name and then it would load all the inputs.

What I'm looking for now is an update command. And luckily we have a We have an update command, let's see how it works. I guess we can update to a specific time, but in this, I don't need to give inputs, then everything is going to be updated. Let's try this, `bead input update`. Then it goes through all of my inputs, in this case, only German state. and all of the `bead boxes` and checks whether there's a newer version of the input that I need. And indeed there is, and then it loads it. I don't think we checked the timestamp before, but we could. we can check that this is the new stuff. It already has the new, it already removed some formatting. So we have updated the version. So when there's a new data release or your coworker or yourself make some change to the upstream `bead`, then you can update the input like this. Here, I think it's always updating to the latest available version, right? If there are multiple new versions.

And you can also ask for a specific version. So, again, if you really care about reproducibility, you probably want to Make sure to load a very particular timestamped version. What did I want to cover here? Load, unload, update. Can we go back? We can probably go back with updating to a specific timestamp, no? That would be my guess.

Krisztián: Yes, there is a previous and next parameter.

Miklós: Indeed, I should read the documentation. Very good, I didn't know this. Thank you. Indeed, I could `bead input update`. But it cannot be. for all inputs, so I would have to specify that I want to do this to German state, right? Very nice, so now it's the previous version. Yes, indeed it is the previous version. Super nice. And so this way I can be sure that what's in my `input/` folder is the proper version that I need. and then I can do my computation, save my stuff in the `output/` folder to ensure that it's reproducible. We didn't give much of an overview of what `bead` is. I guess at some point we can also describe that. You have inputs and you have code and you produce outputs. and you link them into a directed acyclical graph. Once you have all of this, your workflow is entirely reproducible. I think that concludes my dependency section. Any questions, concerns, errors to point out in this section?

Andris: One interesting dependency question also from the data bank, that what happens if your first data that you have to use as an input is hard-coded into a folder and you cannot move? After you can create bits, but the first data is not movable or copyable.

Miklós: Yeah, that's a great question and actually I think on my list of advanced workflows and best practices, we can... So one thing that is already a bit of an edge case for `bead`, which I did at the very beginning, is the source `bead`. When I get my data somewhere, I found it on the street or something, and I just put it into the `output/` folder and save the `bead`. There's no computation involved, I just save it in this. But what you're saying, Andris is that it's a fixed set of folders, maybe because of some data protection reasons they cannot be copied or cannot be moved from there. Then I would say that you can create a source `bead` with some code. I'm going to leave these workspaces open. This is actually another practice question. I tend to leave some of my workspaces open. Let's get back. Some you want to keep open, some you may not. I think, Krisztián, you think of `bead` as, you know, workspaces as really, really transient. You did your work and then `zap` it. We'll get to these type of what I call sync or analysis `beads`. But so in source `beads`, I could imagine that `bead new`, they buy with data. I go into private data and I'm going to create a `Makefile` and I'm going to say `output/filtered_data` and then it could be `/secret/server/secret/folder/`,

Andris: And I could say, I don't know.

Miklós: Okay. So do some script that does, you know, removes the privacy. Of course, if you're not allowed to copy, don't copy it, but if you can filter it or create the data extract, or you can create, you know, remove the, personally identifiable information, then you do this. In this case, your first bid is a bunch of code that directly refers to that thing. I think that's fine. It's an extra constraint that you can only actually run this bid in that environment where that secret server and secret folder can be accessed. So here I have nothing just that make file, and I'm going to pretend that I created something useful there. What did we call it? Build data. So what's inside that private data zip file? The data that I created, which has already been filtered, is in there. So people going forward can use my filtered or extracted or aggregated cleaned up data. And the code that created it, including the hard-coded absolute path, which is typically not a good idea, but if you have no other option, then yeah, let's do that. So I think that's doable. Another thing to consider here is that maybe the actual file names and some of the code might be confidential, so then it might be tricky. Andris, does that answer the question?

Andris: Yes, thank you. They cannot

Miklós: install the make so I mean it can be stated it can be stated but it can be can be done thank you yeah it could be status or python or r or yeah another thing to emphasize which I guess basic design principle they will describe it some other point but things we did not want to force on you is, you know, what's your favorite programming language? We couldn't care less. We ask you to use files because bead is moving files, but that's it, right? There's no other, and it needs to be reasonably sized file. That's another constraint because it's gonna get zipped and it's gonna get copied a number of times. So what is, Bálint and Andris, what is the largest bead that we have worked with?

Bálint: Maybe the Paltorai data.

Miklós: How big is it roughly? Once it's zipped, I'm not on the server now. Just a ballpark.

Bálint: About 400 gigabyte, one table, some kind of this.

Miklós: Yeah. And it can be zipped apparently?

Bálint: Yes.

Miklós: Okay. So, I mean, maybe you have a Windows machine and then, too bad, but I think on proper systems, probably already on Windows, you can work with several hundred gigabyte files and zip them. It may not, to be fair, it may not be from performance point of view, it may not be ideal, but, I think for the kind of workflows that we are working where, you know, if I have a couple, you know, single digit gigabyte file, I already feel like I'm working with big data. Bid is perfectly fine. We have multiple, we are regularly using Bid with one, two, three, four gigabytes of data. No problem at all. And if your data files are smaller, go for it. I use like, For big data, I use .db quite often, or parquet. It might be a db file, it has a flat file format as well. It can be put into beads. Or I save like a big parquet file, can be put into bead. Absolutely no constraints on what scripts you use, what programming language you use, what file format you use. As long as it can be put into a flat file, we can save it. I mean really the only constraint we have is there are these words that we use. So you cannot call your file or folder or script or data input or output or temp or .beatmeta if you will, because those are reserved for beat internal use.

Andris: I have a user question also. Can you create a bead from your own workspace? Like an example, like git init?

Miklós: Oh, that's actually a good, good question. Like if you already have a folder and there's stuff living inside, what do you do? Krisztián, I understand we cannot. So bead new needs an empty folder. that there's no bead in it, for example?

Krisztián: Yeah, I think there is no... There could be, but there isn't.

Miklós: Yeah, so we will talk it up to potential feature requests. What I typically do in this case is I create a new empty bead and I copy over whatever I need or move over whatever I need. We're going to see a special use case of this actually related We looked at how to load data into input and we have raised the question that sometimes you want to look at data that does not live inside the bead. Again, for reproducibility, we think it's good practice that everything should be a bead because that way you can ensure that your computation is exactly reproducible. But what if you run into some constraints. So let me go back to my German cities bid. And suppose I could see two Two examples to put data directly into the bead folder without using the bead toolbox, the bead input head. Let me show how I would do it and then explain why I would do it. I would create a separate folder for this, like external or data external. to already highlight that it's some external stuff. It's like an external dependency, something that I'm not managing with the bead. And then I could, I'm going to nano it. Say, I could use, what names? I could say, Karl Markstadt is now, Okay, so now I have this oldNames.txt in data slash external slash oldNames.txt. So whenever I save this bead, what's going to happen is going to be put as, going to be understood as code. It's going to live in the zip file. And if I bead develop, it's going to come back to data slash external. So it's saved. everything is saved that's not in the temp folder, so not in the temp or the input folder. So this is how I can do it. I'm making it explicit and putting it into a separate folder and then put it there if I really have to. I think one use case is that if this is like three numbers and I think it would be an overkill to introduce a separate bid, like what was the inflation in 2014. It's like hard coding a magic number in your code. It's not good practice, but sometimes you still do it. Okay. And the other is, well, Yeah, I think the other is if it's like a really big data or something and you're under time pressure, you have to leave in three minutes because you're gonna miss your flight. I don't really see any other. Because if it's a medium to big data, you could create its own bead and load it as bead input load. And I think it would be better practition. I mean, you're increasing the complexity a little bit because you have a longer chain of dependencies, so that may be an issue. Something that I forgot to mention in the dependency section is that, and it's related to this issue of the complex chain of dependencies, I think the German cities data has already some dependency. And I think we have reviewed the input, the metadata that the input is declared German states. But very, very important, the input itself is not saved into the bit. So it's only the reference to the input. So you have all the metadata about the input that is needed to uniquely identify, make sure that you can find it and load the correct version, but the actual input is not saved. So this is saving you some storage. So here you have, for example, an external data set. and you create another bead and you want to share it with someone, you would have to share both beads, the external and your own. Because each bead only includes its own data, not the input data. I don't know if that had clarified this or maybe made it more complicated. Some other, some of the best practices we already covered, basically like keep your root folder clean, I think, but that's in general a good practice. Nkdir is your friend. Create copious number of subfolders. Documentation put into the output folder because that's where your users are going to see it. Again, I mentioned I like to have a makefile in the root. This is not enforced. If you use data, you can have like a main.do in the root. Totally fine. I think it's good practice to have some main script that shows you how to run everything, all the computations. So the typical beat is very, so in terms of the workflow, as we were discussing, the typical bead is very transient, so you want to bead save quite often and you want to bead zap quite often. So, if you, after a sprint, if you're doing Agile and you're done with a whole bunch of new functionality, you definitely want to bead save it and that's how you share your data with others. And then you can immediately bead zap it. Now, I think One issue is that Bitsave is basically, if you're familiar with version control like Git, then Bitsave is something like Git commit and Git push in one go, right? Because you create a new version and you put it someplace. And I don't know, so that's a practice, I don't know, so I don't really work with data cleaning beads a little bit, but I think Andris and Bálint work much more with data cleaning type beads, like how often you save your beads. Because one benefit is like committing often is that you can track the changes better, you can see what changed and not a whole lot of things changed, but then you're gonna have a lot of you're gonna have a lot of zip files and there's no commit message. So there's no interpretation of what those timestamps really mean. So personally, I don't think I would be safe like multiple times a day, maybe like once a day, but I don't know. And of course, if there's a new, if someone asked me for a new version, I want to make sure that they get the correct version, but if I'm just working, working, working in a sprint for like two weeks, I might have in that sprint, I might have like a couple of bits saved, but not more than that. Bálint, what do you think about this?

Bálint: I think basically you save if you want to use that beat as an input later. So if you have a chain of beats and you're developing a beat and in separate beats, then you always save. But if you are just debugging and I don't know, it's maybe not so useful to generate so many beats.

Miklós: That's a good point, actually. Gary, you wanted to add something as well? You did not, that's okay. I think this is a good segue into another advanced topic, which is a controversial topic of the day, is versioning with or without bead. And I think, Bálint, what you said is that you have many changes and you're often debugging and stuff, but you don't necessarily want to be saved every five minutes. Whereas I think even for debugging version control can be useful. So the way we are... Very often, not always, but very often we are using Git inside the bead, which is a little bit of an off-label use at present, but we can do it because the only constraints that it has, I already told you. It has no constraint that there shouldn't be any .git folder in your beads. If I go into my private data bead, And then I could... Distributed structure, the whole point, of course. The only thing they need for this is a subfolder inside your folder called .git, and that's it. There's no external dependency other than having the git command available to you. Oops, was it too much? Because now we've got all the .git information as well, but now we have .git. So if I bid save it, then we can actually see that.

Andris: It's not the proper version I'm using.

Miklós: 59. Now it gets treated as code, right? Why? Because it's not an input, it's not in temp, and it's not an output. So it gets treated as code and it gets saved. So whatever you put into the Git repository, you put it there, it's going to be saved. So I find it useful to keep track of versions for debugging purposes, even without saving a new bit. So when I'm working in an open workspace, I still often use Git as a version control tool. But the way I tend to use it is to keep a bid save more as a push rather than the commit itself. So yes, there's this whole bunch of changes that I really like and I want to share it with the world. I want to save it into my bid box. There you go. But it might already be like four days worth of work and I already have like 40 different commits in my repository. And because, of course, if I have the Git repository, then I have... Of course, it helps if we add something to the repository. I have not created a readme because I was lazy. And so then I have some metadata, like who created this commit, when, how did they describe that change? So it is, you know, it's really helpful. So then I think, again, it's kind of undocumented off-label use, but it's totally fine. There's not even a constraint that we run into. Whenever I do this, I actually, I would, I would begin to create a get ignore. So I want to make sure that stuff in the input folder is not saved because the bead is not saving the input and stuff in the temp folder is not saved. And sometimes I want to ignore the bead meta. This gitignore would play nice with Git, I'm sorry, with Bid, because whenever I'm creating a new commit or something, it's not touching any of the sensitive folders or the reserved folders of I probably want to ignore the output folder anyway. It's like a build folder where I put the stuff that I created. And if you're doing properly reproducible research, you can recreate it anyway. Those should typically not be put under source code control. Or completeness. Right? So if you do this, Krisztián, and I think it, you know, there's nothing wrong. It plays nice with that.

Krisztián: Yeah, it is. It's done this way. It is just parting the code, what would go into the code.

Miklós: Yeah. And of course, if I have this local, so Now, I think most people use Git with GitHub, but that's just an added feature. We have this local Git folder. We can add a remote to GitHub and then have functions. Let me raise one other topic and then I think we're done and it's going to be related to this Git stuff. Now we may still have some, I think we discussed some features and some more advanced topics. So one type of bead that I use very often because I'm an analyst, not really a data engineer, is what I call analysis bead or a sink bead. If you think of your directed acyclical graph, a bead has inputs, and it can serve as inputs to others. So a sink bead is a bead that is not an input to any other. It's the end of the line in the directed graph. And I think most analysis beads are like this. So what do I mean by an analysis bead? That where I load my data and I run some regressions or plot some figures and then write a paper. And so until journals start accepting beads as inputs to their pipelines, this is really going to be a thing. It's the last time this bead lives as a bead, because in your output folder, you already have a figure.pdf and then a paper.pdf. So I could create a new bead called paper. and it's going to have inputs, where it uses data. It's going to use German cities, maybe it will also use the private data, be the input, sorry. So now I have the German cities data, the private data, And then I can do my code.

Andris: I don't know what.

Miklós: I can say output slash figure not PDF. And then there's a massive computation. I run my code and it actually saves output slash figure dot PDF. So this is a bid. I opened it as a bid. It has two inputs, it has some code, it produces an output. So I can, I'm totally free to save it just like we did before and it's going to create a nice zip file and everything. So it's fine, I can share it with my co-authors, I can send it to a journal. But I think what is a big difference is that here because I'm typically not sharing this as a bead with others. Even if I'm sharing it with others, I only need to share the figure PDF or the paper PDF and not all the different computations. Most of the time I actually leave this workspace open. So I don't even ever close this workspace. I keep working on my, now I create another figure. I change the analysis scripts. And so here I would be using version control as well, just like we did before. So I could add the SRC and the make file, for example. I could be using version control and I even have beads that I never save, not even once. I created a new bead and I have not even saved it once. So I cannot really use the bead save for version control because I either never save it or save it like once every three months, whereas with commit, I'm going to issue like 10 a day. So that's fine. We've seen how this works before, so that's doable. But an additional issue here is that something that changes in the analysis quite often is the dependency on input data. So I'm doing my analysis, I'm happy, and then Bálint update the German cities data. I guess I haven't specified the versions. And so then I need to be able to update my data sets, maybe just a very specific one, maybe just the private data. These are now all up to date. And so then I want to, whenever I do version control and I'm afraid of making mistakes and debugging, which is always, I want to also version the exact reference to the input data. So let me show you how I do this and then see what happens. So because of that, I am actually versioning the beadmeta as well. So let me add the beadmeta folder to git. So that's just a text file, it's a JSON file, I believe, so totally fine to version. Now I go outside. Let's see, I still have my private data open. I'm going to, I forgot what's in here. I'm going to create, ooh, sorry, sorry. I'm going to create a new version of the private data. So this is my new version of the private data. I save the new version of the private data with the new timestamp, and then I go back to my analysis bead. Let's check the... timestamps there. So I was using, and now it's actually under version control, I was using the 1659 version of private data, and there's a newer version, 1711. And now I can consciously decide that, hey, I want to get the new version. I think So now they say we're really moving into the territory where we can step on the toes of BEEP. So I'm going to try to use it in a safe way and Krisztián will tell me if it's okay or not. I can unload the private data. Right, it's no longer in the input folder. But I still have the metadata that I need about it. That's not what I wanted to. Let me load it again. Let me update. If I say Bid Input Update, it tries to update both input German cities and private data. German cities is already at requested version, very useful message. And private data is newer, so it's basically updating now. Let me show what I see in my Git status. The Bid meta has been modified. Now I have a new version of the private data with a new freestyle, new content ID. I am actually fine with the change. It is quite important for me. I haven't staged the change. Because this way I can make sure that The code that I'm running is running on the correct version of the data. So this I think is still fine. So maybe actually when we were using Git inside the bead, versioning bead meta is probably still fine. I think when it can lead into trouble is if we were so sharing the sharing the folder with Git. So not just creating newer and newer commits, but I'm modifying the content of the folder via Git by pushing and pulling from remote. For example, that can be tricky because then I might get... getting a Git pool from GitHub, for example, I might get a new, an update to my bead meta that bead doesn't know anything about. So, and that's not playing nice. So that's the basically going beyond the current capabilities of bead because we are modifying an internal file of bead. And the kind of issues that it can raise is that, for example, I did this in the past. I can show it, but it's on my GitHub. And I was cleaning up a repo, an analysis repo that has been going on for years, and we were already using like six, seven different inputs, and I realized we don't need many of those, and I deleted, say, four of them. And then I wanted to implement those changes. But if you delete them from the bead meta, then it's actually very hard to delete them from the input folder later because bead doesn't know that they are there in the input folder. So there are issues like this, but this we definitely don't need in the docs yet. I think we want to discuss this in more detail in person as a potential feature request. I just wanted to show this a little bit. Yeah, maybe two more things to mention. These are just quick mentions. One is that sometimes not every computational step can be done by code, and that's okay. We call this the human-in-the-loop beads. As long as you document what you did, you can still use the bead. Whenever your human is done, After a week of work, they can save a new bit and that's fine. I mean, to be fair, I was doing this the entire time in this demo because none of the code actually ran. I was just typing the data by hand. So that's totally doable if you really need to. And I just want to mention that because it's such a simple and flexible tool, it's also super easy to extend. So it's not only agnostic about what you use inside, but you can, you know, it uses a JSON metadata for, JSON files for storing the metadata, a simple zip file to storing the actual data. So it's very easy to develop on top of Bead. So now in our Bead universe, we have, I think it was Oliver who did this Bead archival script. to basically periodically clean up beat boxes to move all the old versions of beats to an archive box. Or Cristiano did, I don't think I ever used it, but the web display creating the, like visualizing the links between different beats in the graph. Sometimes we use it as like we looked at the graph, but typically this can become very complex very soon. What else? You could, so even if B does not implement this, you could write your own tool that says, let me add a single entry point into a bead, like every bead I'm going to go and look for a make file and execute it. and totally fine to do. I think it would be possible to load all the bits that are needed for your data project and then execute all the make files in the correct order. This is, I forget what it's called, but this dependency ordering is a well-known test that's easy to solve. And then you can kind of automatically compute the output of the bead. Right now it's typically done by humans. So I think that's all I wanted to do in the demo, unless you have additional questions or comments.

## Advanced Features

Andris:

One comment is that it would be great to show the `bead web`, because this is how the graphs can be shown to totally new people. And also there are links there with the color type of the data that which data comes first and how many archives we have from one `bead`. And yes, when I did the demo for the data bank, they were impressed by those web graphs.

Miklós: Cool. Yeah, I think that's, and actually for, so I'm, I think I'm going to, no, let's, I think for the, for the actual documentation and demo and everything, we need, of course, real data, even if very small, and multiple `beads`. So not just two, but I would say four or something like, you know, A and B leading to C and C leads to D or something like that. Because you need to kind of see the graph and be able to visualize that kind of conceptualize what's going on. And yes, you need different versions and the web graph was so color coded. I think that's great. Another thing to decide for the, I think both the demo and the, or the presentation and the documentation is that what, you know, data format, I think data format could be CSV because that's the easiest. and what scripting language are, because I think it should be kind of workable example that people can actually run if they want. And we should always emphasize that you can do whatever, but I think an actual program that computes stuff is useful. So maybe like a three line Python script or or a one-line shell script or something like that. That's something to discuss. Probably not Stata, because... I mean, even though most of our... I guess we can create a Stata version at some point, because probably most of our audience is going to be economists, and then it's not at the RSC conference, but otherwise. So any con people know Stata, even if they deny it. And maybe for everybody else, Python is the most relatable programming language. Let me create a minimal example there. I also like DuckDB a lot, but I don't think it's widely adopted enough yet to be used as a demo tool. Sorry, what was that? DuckDB. Krisztián, you know DuckDB?

Krisztián: I heard about it.

Miklós: It's awesome. So it's like SQLite for analytics. And for the kind of the way we use, because we are doing analytics, that's all we need ever, all we need about databases. So we always struggled with database maintenance. like what is even a database, what is Postgres and all that, and how do you set it up and what's the schema and how do you connect and all that. And the fact that you have a single tool, if you even want to keep the file in a single flat file, and it's like super, super fast analytical queries, they're just the best of both worlds. So I love it. Okay, let me stop the recording.

---

*End of transcript*
